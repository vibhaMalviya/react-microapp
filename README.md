# microapp sse template

This repo is meant to be used for the creation of new SSE Micro Apps. Just click the [Use This Template](https://github.office.opendns.com/micro-apps/microapp-sse-template/generate) button above to generate a _new_ repository that acts as the foundation of your new Micro App.

_Replace the contents of this README.md file when you create your Micro App_

// TODO update me

## Requirements

The Micro Apps generated by this repo will almost certainly require an APIv3 server in order to function. This follows the already established way of operating APIv3 out of the website repository, and requires you to export the following environment variables:

See the Development API Tokens section of the developer docsite [here](https://pages.github.office.opendns.com/OpenDNS/developer-docsite/docs/developer-guides/microapps/getting-started/);.

## Usage

The files in the project root are the typical configuration files for the build tools. ESLint, Babel, webpack, etc all have their configurations here. Some are configured within the package.json file.

The `src/` directory contains all of your app's logic/code. We've prepared it with a very simple example feature that includes a section component, a unit test and stylesheet.

// STILL TODO: i18n is configured out of the box. [Micro Apps use React i18Next](https://react.i18next.com/) for translations. We've prepared some sample language files so you get an idea of the configurations it uses.

The `entry/` directory holds files __only__ used during local development. It's meant to accurately simulate how your Micro App will be loaded by the dashboard in production and as such contains some stripped down files that represent that.

The `ci/` directory contains configuration for the Ci/Cd server, including a Pull Request builder. You should not have to modify this at all.

## CI/CD with Concourse

Once you are ready to start creating PRs and releasing production builds you can setup your project in the micro-apps Concourse server.  The package.json includes a few commands to help this process:

First you'll want to login to Fly:

```commandline
yarn ci:login
```

Now you'll want to push your pipelines up - first update your `.ci.yml` to the values specific for your micro-app.  

Then create your pipelines:

```commandline
yarn ci:update-pr-pipeline
yarn ci:update-release-pipeline
```

## Architecture

Micro Apps are the name given to React applications that can be loaded in concert by a parent application. Your Micro App represents one section (or a few) of the overall Umbrella Dashboard. Other Micro Apps exist that handle different sections and features. Aside from a few specific configurations and conventions, this is a very standard React application that's meant to communicate with an API for data. It compiles React and future JS code with Babel, provides syntax linting with ESLint, unit testing with Jest, and bundles your app for production with webpack.

We mentioned `entry/` earlier. One of the special setups for Micro Apps are their entry points. When you run `yarn start` in your project directory, webpack bundles and runs a local web server in order to execute your application. Depending on who is running your application, that entry point differs.

- When you run your application locally, to develop features, the entry point is `entry/index.jsx`
- When Dashboard hosts your application in production, the entry point is `entry/Component.jsx`

Why the difference? `index.jsx` represent the same code that The Dashboard application uses. In the same way your Micro App imports different components you build, The Dashboard loads (imports) whole Micro Apps as "Components". As such, `index.jsx` contains more code than necessary in production because The Dashboard also loads this code so that your Micro App runs the same on your local machine:

- polyfills to support JS features across different browsers and versions
- a `manifest` that is the JSON representation of the main navigation
- an index HTML file that represents The Dashboard's entry point-the file it serves to start the whole app

A simplified architecture looks like this:

<img src="https://dknzq02jhlqlk.cloudfront.net/simplified-arch.png" alt="drawing" width="200"/>

Visually, you can think of it like this:

<img src="https://dknzq02jhlqlk.cloudfront.net/visual-arch.png" alt="drawing" />

## Routing

If your application contains multiple sections, nested under a major navigation category, you will add your routes to the `entry/manifest.js` file. Again, this file represents the main navigation structure. It is used by The Dashboard to create the links to each Micro App (or external, third party app as the case may be).

```js
menu: [
    {
        id: 'micro-app',
        i18n: { en: 'Your Microapp', ja: 'Your Microapp in Japanese' },
        sub: [
            {
                id: 'feature',
                i18n: { en: 'Your Feature', ja: 'Your Feature in Japanese' },
                target: { type: 'microapp', id: 'microApp' },
                path: '/section/route',
            },
        ],
    },
    ...
```

The above is the out of the box example created by this template for your Micro App. This creates a React Router route at: `http://localhost:3000/org/2/section/route`. It results in a visible navigation like:

<img src="https://dknzq02jhlqlk.cloudfront.net/nav1.png" alt="drawing" width="280"/>

If we edit the `manifest.js` to this:

```js
menu: [
    {
        id: 'micro-app',
        i18n: { en: 'Your Microapp', ja: 'Your Microapp in Japanese' },
        sub: [
            {
                id: 'feature',
                i18n: { en: 'Your Feature', ja: 'Your Feature in Japanese' },
                target: { type: 'microapp', id: 'microApp' },
                path: '/section/route',
            },
            {
                id: 'another-feat',
                i18n: { en: 'Your Other Feature', ja: 'Your Other Feature in Japanese' },
                target: { type: 'microapp', id: 'microApp' },
                path: '/section/route-two',
            },
        ],
    },
    ...
```

Now we have two routes:

- http://localhost:3000/org/2/section/route
- http://localhost:3000/org/2/section/route-two

<img src="https://dknzq02jhlqlk.cloudfront.net/nav2.png" alt="drawing" width="280"/>

What React component(s) are loaded at these routes? That depends on your application router setup. In `App.jsx` we have the following:

```jsx
<Switch>
    <Route path={['/:orgId/section/route', '/section/route']}>
        <SomeFeature />
        <SomeClass />
    </Route>
</Switch>
```

so we could easily add a second:

```jsx
<Switch>
    <Route path={['/:orgId/section/route', '/section/route']}>
        <SomeFeature />
        <SomeClass />
    </Route>
    <Route path={['/:orgId/section/route-two', '/section/route-two']}>
        <SomeOtherFeature />
    </Route>
</Switch>
```

## Renovate Bot

Renovate is a software robot. Itâ€™s an open-source software program that is intended to keep your software dependencies up-to-date. It does this by scanning your github repos
and checking for updates to your dependencies. It can then open pull requests or github issues.

By default, this repository is configured to have renovate bot open a special github issue called "Dependency Dashboard". It will list all of the deps with updates in there with a checkbox next to it. If you check the checkbox, the next time renovate runs it will open a PR for that dependency. It will keep this issue updated.

To configure renovate-bot to scan your repo, add the github user `renovate-bot.gen` as a collaborator with `write` access to your repo.

Then, add your repository to the list of repos here: https://github.office.opendns.com/OpenDNS/renovate-bot/blob/master/repos.json

Open a PR with that, get it merged, and the next time the bot runs, it will start doing it's thing.

## Conventional Commits

When committing to your Micro App repo, it is advisable to use Conventional Commits as a format. This offers many benefits. Mainly, improving skimability/readability of commits and PRs and allowing automation to easier parse git data for tooling/convenience functions.

Each commit message consists of a **header**, a **body** and a **footer**.  The header has a special
format that includes a **type**, a **scope** and a **subject**:

```bash
<type>(<scope>): <subject>
# BLANK LINE
<body>
# BLANK LINE
<footer>
```

The **header** is mandatory, the **scope** of the header and **body** are optional.

Any line of the commit message cannot be longer 100 characters! This allows the message to be easier
to read on GitHub as well as in various git tools.

The footer should contain a [closing reference to an issue](https://help.github.com/articles/closing-issues-via-commit-messages/) if any.

Samples: (even more [samples](https://github.com/angular/angular/commits/master))


```bash
$ git commit -m "docs(changelog): update changelog to beta.5"
```
```bash
$ git commit

# in your git editor...
fix(release): need to depend on latest rxjs and zone.js

The version in our package.json gets copied to the one we publish, and users need the latest of these.
```

### Revert
If the commit reverts a previous commit, it should begin with `revert: `, followed by the header of the reverted commit. In the body it should say: `This reverts commit <hash>.`, where the hash is the SHA of the commit being reverted.

### Type
Must be one of the following:

* **chore**: A change that doesn't actually affect the code
* **build**: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)
* **ci**: Changes to our CI configuration files and scripts (example scopes: Circle, BrowserStack, SauceLabs)
* **docs**: Documentation only changes
* **feat**: A new feature
* **fix**: A bug fix
* **perf**: A code change that improves performance
* **refactor**: A code change that neither fixes a bug nor adds a feature
* **style**: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
* **test**: Adding missing tests or correcting existing tests

### Subject
The subject contains a succinct description of the change:

* use the imperative, present tense: "change" _not_ "changed" nor "changes"
* don't capitalize the first letter
* no dot (.) at the end

### Body
Just as in the **subject**, use the imperative, present tense: "change" not "changed" nor "changes".
The body should include the motivation for the change and contrast this with previous behavior.

### Footer
The footer should contain any information about **Breaking Changes** and is also the place to
reference GitHub issues that this commit **Closes**.

**Breaking Changes** should start with the word `BREAKING CHANGE:` with a space or two newlines. The rest of the commit message is then used for this.
